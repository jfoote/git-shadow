#!/usr/bin/env python
# 
# Jonathan Foote
# jmfoote@loyola.edu

import subprocess, re, sys, os, json, difflib, shutil, filecmp


'''
Git utility functions
'''

def get_repo_path(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    return subprocess.check_output(["git", "rev-parse", "--show-toplevel"], 
            cwd=path).strip()

def get_branch(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    text = subprocess.check_output(["git", "branch"], cwd=path)
    line = [l for l in text.splitlines() if "*" in l][0]
    return line.strip("* ")

def get_filepath_relative_to_repo(filepath):
    dirpath, filename = os.path.split(filepath)
    repo_rel_dirpath = subprocess.check_output(["git", "rev-parse", "--show-prefix"], cwd=dirpath).strip()
    return os.path.join(repo_rel_dirpath, filename)

def commit(cwd, message="git-shadow"):
    subprocess.check_call(["git", "commit", "-m" "'%s'" % message], cwd=cwd)

def get_commit_id(cwd):
    return subprocess.check_output(["git", "log", '--format=%H', "-n", "1"], 
            cwd=cwd).strip()


'''
Shadow repo management functions
'''

def add_shadow_repo(cwd="."):
    '''
    Hack that adds shadow repo to enclosing git repo. Run as a pre-commit hook,
    for example.
    '''
    shadow_git_repo_path = os.path.join(".shadow", ".git")
    if not os.path.exists(shadow_git_repo_path):
        raise RuntimeError("git-shadow hook is installed, but shadow repository "
            " doesn't exist at '%s'. Try 'git shadow deactivate [repo]'." %\
            shadow_git_repo_path)

    # rename shadow's git repository 
    shadow_repo_storage_path = os.path.join(".shadow", "git")
    shutil.move(shadow_git_repo_path, shadow_repo_storage_path)
    
    # git add shadow directory
    subprocess.check_call(["git", "add", os.path.join(".shadow", "*")], cwd=cwd)

def get_shadow_repo_path(path):
    '''
    Gets the absolute path to the shadow repo for the repo containing 'path'
    '''
    return os.path.join(get_repo_path(path), ".shadow")

def delete_shadow_repo(path):
    '''
    Deletes shadow repository from toplevel repo containing 'path' (i.e. path 
    can be a filepath anywhere within the repo)
    '''
    spath = get_shadow_repo_path(path)
    if not os.path.exists(os.path.join(spath, ".git")): # try to avoid bumblebee
        raise RuntimeError("No shadow repo found at '%s'" % get_repo_path(path))
    subprocess.check_call(["rm", "-rf", spath], cwd=spath)

def create_shadow_repo(cwd=".", force=True):
    '''
    Creates a new shadow repo in the conventional subdir below cwd. If shadow 
    repo dir exists and force is False, the script errors out. Otherwise the
    old repo is deleted before the new one is created.
    Called when shadow is initialized and by hooks (such as post-commit).
    '''
    shadow_repo_path = get_shadow_repo_path(cwd)
    if os.path.exists(shadow_repo_path):
        if force == False:
            raise RuntimeError(".shadow already exists in %s" % shadow_repo_path) 
        else:
            delete_shadow_repo(cwd)
 
    # make shadow repo
    subprocess.check_output(["git", "init", shadow_repo_path], cwd=cwd)

def add_hooks(cwd):
    '''
    Create (or add to) git hook files that call git-shadow. 
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["pre-commit", "post-commit", "pre-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        if not os.path.exists(filepath):
            with open(filepath, "wt") as fp:
                fp.write("#!/bin/sh\ngit shadow %s\n" % hook)
        else:
            with open(filepath, "at") as fp:
                fp.write("\ngit shadow %s\n" % hook)

def remove_hooks(cwd):
    '''
    Remove git-shadow hooks from git repo
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["pre-commit", "post-commit", "pre-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        lines = [l.strip() for l in open(filepath, "rt").readlines()]
        lines = [l for l in lines if "git shadow" not in l]
        # if this hook file was created by git-shadow, delete it
        if len(lines) == 1 and "#!/bin/sh" in lines[0]:
            os.remove(filepath)
        else:
            open(filepath, "wt").write("\n".join(lines))


'''
File shadowing functions
'''

def shadow_controlled_files(src_repo_path):
    '''
    Adds all controlled files from repo containing src_repo_path to the
    corresponding shadow repository and commits them
    '''
    src = get_repo_path(src_repo_path)
    print "SRC", src
    dst = get_shadow_repo_path(src_repo_path)
    rel_fps = subprocess.check_output(["git", "ls-tree", "-r", "HEAD", "--name-only"], cwd=src).strip().splitlines()
    changed = False
    for rel_fp in rel_fps:
        dst_filepath = os.path.join(dst, rel_fp)
        dst_dirpath, dst_filename = os.path.split(dst_filepath)
        src_filepath = os.path.join(src, rel_fp)
        try:
            if not os.path.exists(dst_dirpath):
                subprocess.check_call(["mkdir", "-p", dst_dirpath], cwd=src)
            shutil.copy(src_filepath, dst_filepath)
            subprocess.check_call(["git", "add", dst_filepath], cwd=dst)
            changed = True
        except Exception as e:
            import logging
            logging.error("error copying %s to %s, probably uncommitted 'git mv'" % (src_filepath, dst_filepath))
            logging.exception(e)
    if changed:
        commit(dst, get_commit_id(src))

def shadow_file(filepath, buffer_path):
    '''
    Diffs contents (respectively) of filepath and buffer_path; if the buffer
    contents are different, the file corresponding to filepath is copied from
    the enclosing repo to the shadow repo and committed to the shadow repo.
    '''
    if not filecmp.cmp(filepath, buffer_path, shallow=False):
        rel = get_filepath_relative_to_repo(filepath)
        shadow_repo = get_shadow_repo_path(filepath)
        dst = os.path.join(shadow_repo, rel)
                
        shutil.copy(buffer_path, dst)
    
        subprocess.check_call(["git", "add", rel], cwd=shadow_repo)
        subprocess.check_call(["git", "commit", "-m", "'file_modified'"], cwd=shadow_repo)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        sys.stderr.write("not enough args")
        sys.exit(-1)

    if len(sys.argv) > 2:
        cwd = sys.argv[2]
    else:
        cwd = "."

    if sys.argv[1] == "activate":
        create_shadow_repo(cwd=cwd, force=True)
        shadow_controlled_files(cwd=cwd)
        add_hooks(cwd=cwd)
    elif sys.argv[1] == "deactivate":
        remove_hooks(cwd=cwd)
        delete_shadow_repo(cwd)
    elif sys.argv[1] in ["pre-commit"]:
        add_shadow_repo(cwd=cwd)
    elif sys.argv[1] in ["post-commit", "pre-checkout"]:
        create_shadow_repo(cwd=cwd, force=False)
        shadow_controlled_files(cwd=cwd)
    elif sys.argv[1] == "add-hooks":
        add_hooks(cwd)
    elif sys.argv[1] == "remove-hooks": 
        remove_hooks(cwd)
    elif sys.argv[1] == "shadow-file":
        import pickle
        filepath = sys.argv[2]
        buffer_path = sys.argv[3]
        shadow_file(filepath, buffer_path)
    else:
        # run git command in mirror directory of shadow repo
        pass
