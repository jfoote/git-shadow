#!/usr/bin/env python
# 
# Jonathan Foote
# jmfoote@loyola.edu

import subprocess, re, sys, os, json, difflib, shutil, filecmp


'''
Git utility functions
'''

def get_repo_path(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    return subprocess.check_output(["git", "rev-parse", "--show-toplevel"], 
            cwd=path).strip()

def get_branch(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    text = subprocess.check_output(["git", "branch"], cwd=path)
    line = [l for l in text.splitlines() if "*" in l][0]
    return line.strip("* ")

def get_filepath_relative_to_repo(filepath):
    dirpath, filename = os.path.split(filepath)
    repo_rel_dirpath = subprocess.check_output(["git", "rev-parse", "--show-prefix"], cwd=dirpath).strip()
    return os.path.join(repo_rel_dirpath, filename)

def get_commit_id(cwd):
    return subprocess.check_output(["git", "log", '--format=%H', "-n", "1"], 
            cwd=cwd).strip()


'''
Shadow repo management functions
'''

def get_shadow_path(path):
    '''
    Gets the absolute path to the shadow repo for the repo containing 'path'
    '''
    return os.path.join(get_repo_path(path), ".shadow")

def get_current_path(cwd):
    return os.path.join(get_shadow_path(cwd), "current")

def create_current(cwd="."):
    '''
    Creates a <repo>/.shadow/current and adds in controlled files to it. 
    '''
    path = get_current_path(cwd)
    if os.path.exists(path):
        print("dir already exists: %s" % path) 
        return
    os.makedirs(path)
    subprocess.check_output(["git", "init", path], cwd=cwd)
    shadow_controlled_files(get_repo_path(cwd), path)

def add_hooks(cwd):
    '''
    Create (or add to) git hook files that call git-shadow. 
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["post-commit", "post-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        if not os.path.exists(filepath):
            with open(filepath, "wt") as fp:
                fp.write("#!/bin/sh\ngit shadow %s\n" % hook)
            subprocess.check_call(["chmod", "+x", filepath]) # TODO: POSIX only
        else:
            with open(filepath, "at") as fp:
                fp.write("\ngit shadow %s\n" % hook)

def remove_hooks(cwd):
    '''
    Remove git-shadow hooks from git repo
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["post-commit", "post-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        if open(filepath, "rt").read() == ("#!/bin/sh\ngit shadow %s\n" % hook):
            os.remove(filepath)
        else:
            lines = [l.strip() for l in open(filepath, "rt").readlines() if l.strip() != "git shadow %s" % hook]
            open(filepath, "wt").write("\n".join(lines))


'''
File shadowing functions
'''

def shadow_controlled_files(src, dst):
    '''
    Adds and commits all controlled files from repo at src to repo at dst. 
    '''
    try:
        rel_fps = subprocess.check_output(["git", "ls-tree", "-r", "HEAD", "--name-only"], cwd=src).strip().splitlines()
    except subprocess.CalledProcessError:
        # this happens when there are no commits in the repo: fatal: Not a valid object name HEAD
        print "no HEAD"
        return
    changed = False
    for rel_fp in rel_fps:
        dst_filepath = os.path.join(dst, rel_fp)
        dst_dirpath, dst_filename = os.path.split(dst_filepath)
        src_filepath = os.path.join(src, rel_fp)
        try:
            if not os.path.exists(dst_dirpath):
                subprocess.check_call(["mkdir", "-p", dst_dirpath], cwd=src)
            shutil.copy(src_filepath, dst_filepath)
            subprocess.check_call(["git", "add", dst_filepath], cwd=dst)
            changed = True
        except Exception as e:
            import logging
            logging.error("error copying %s to %s, probably uncommitted 'git mv'" % (src_filepath, dst_filepath))
            logging.exception(e)
    if changed:
        subprocess.check_call(["git", "commit", "-m" "'%s'" % get_commit_id(src)], cwd=dst)

def shadow_file(filepath, buffer_path):
    '''
    Diffs contents (respectively) of filepath and buffer_path; if the buffer
    contents are different, the file corresponding to filepath is copied from
    the enclosing repo to the shadow repo and added/committed to the shadow 
    repo.
    The shadow repo is created if it does not exist.
    '''
    create_current(os.path.dirname(filepath))
    if not filecmp.cmp(filepath, buffer_path, shallow=False):
        current = get_current_path(filepath)
        rel = get_filepath_relative_to_repo(filepath)
        dst = os.path.join(current, rel)
                
        shutil.copy(buffer_path, dst)
    
        print "committing %s to %s" % (dst, current)
        subprocess.check_call(["git", "add", rel], cwd=current)
        subprocess.check_call(["git", "commit", "-m", "'file_modified'"], cwd=current)

def checkout_shadow(cwd):
    # 1. copy .shadow/<commit id> to .shadow/current; this is a "read" operation on the shadow
    #    - if the user has abandoned changes to .shadow/current, it will be necessary to delete it first
    path = get_commit_path(cwd)
    if os.path.exists(path):
        raise RuntimeError("repo for commit already exists at %s" % path) 
    shutil.move(get_current_path(cwd), path)

def commit_shadow(cwd):
    # 1. move .shadow/current to .shadow/<commit id>; this is a "write" operation on the shadow
    #    - .shadow/<commit id> should not exist, as re-writes of commits aren't usually done with an editor !
    path = get_commit_path(cwd)
    if os.path.exists(path):
        raise RuntimeError("repo for commit already exists at %s" % path) 
    shutil.move(get_current_path(cwd), path)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        sys.stderr.write("not enough args")
        sys.exit(-1)

    if len(sys.argv) > 2:
        cwd = sys.argv[2]
    else:
        cwd = "."

    if sys.argv[1] == "activate":
        add_hooks(cwd=cwd)
    elif sys.argv[1] == "deactivate":
        remove_hooks(cwd=cwd)
    elif sys.argv[1] in ["post-commit"]:
        commit_shadow(cwd)
    elif sys.argv[1] in ["post-checkout"]: 
        checkout_shadow(cwd)
    elif sys.argv[1] == "shadow-file":
        # 1. create repo .shadow/current if it doesn't exist
        # 1. if different, add the file to .shadow/current/<path> and commit it to .shadow/current
        filepath = sys.argv[2]
        buffer_path = sys.argv[3]
        shadow_file(filepath, buffer_path)
    else: # analyze
        # run git command in mirror directory of shadow repo
        # 0. if .shadow/current doesn't exist, bail with message
        # 1. cd to .shadow/current
        # 2. run command
        pass

"""
TODO:
    0. BEST*** store repos in .shadow/<commit_id> and *don't* commit them with the repo (make a special repo for .shadow/.current)
       - solves all this git hackery
       - does not cause shadow to be in git repo; *completely* transparent
    1. store shadow to a zip file (or other single file) so that it doesn't clutter up git ls-tree, etc. Do it like this for now, to avoid complexity:
        - .shadow/history.zip # always in parent repo (after first commit)
        - .shadow/live/.git, etc. # always added to .gitinore 
    2. figure out why .shadow/git still exists after a commit
    3. fix post-checkout logic
    4. cleanup
    5. Advertise no support for history re-writing: re-ordering may work, but squashing/splitting and filter-branch probably won't
"""
