#!/usr/bin/env python
# 
# Jonathan Foote
# jmfoote@loyola.edu

import subprocess, re, sys, os, json, difflib, shutil, filecmp


'''
Git utility functions
'''

def get_repo_path(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    return subprocess.check_output(["git", "rev-parse", "--show-toplevel"], 
            cwd=path).strip()

def get_branch(path):
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    text = subprocess.check_output(["git", "branch"], cwd=path)
    line = [l for l in text.splitlines() if "*" in l][0]
    return line.strip("* ")

def get_filepath_relative_to_repo(filepath):
    dirpath, filename = os.path.split(filepath)
    repo_rel_dirpath = subprocess.check_output(["git", "rev-parse", "--show-prefix"], cwd=dirpath).strip()
    return os.path.join(repo_rel_dirpath, filename)

def get_commit_id(cwd):
    return subprocess.check_output(["git", "log", '--format=%H', "-n", "1"], 
            cwd=cwd).strip()


'''
Shadow repo management functions
'''

def add_shadow_repo(cwd="."):
    '''
    Hack that adds shadow repo to enclosing git repo. Run as a pre-commit hook,
    for example.
    '''
    shadow_git_repo_path = os.path.join(".shadow", ".git")
    if not os.path.exists(shadow_git_repo_path):
        raise RuntimeError("git-shadow hook is installed, but shadow repository "
            " doesn't exist at '%s'. Try 'git shadow deactivate [repo]'." %\
            shadow_git_repo_path)

    # rename shadow's git repository 
    shadow_repo_storage_path = os.path.join(".shadow", "git")
    shutil.move(shadow_git_repo_path, shadow_repo_storage_path)
    
    # git add storage directory
    subprocess.check_call(["git", "add", os.path.join(".shadow", "git", "*")], cwd=cwd)

def get_shadow_repo_path(path):
    '''
    Gets the absolute path to the shadow repo for the repo containing 'path'
    '''
    return os.path.join(get_repo_path(path), ".shadow")

def delete_shadow_repo(path):
    '''
    git-rm's shadow repository ('.shadow' and its contents) from toplevel repo 
    containing 'path' (i.e. path can be a filepath anywhere within the repo)
    '''
    spath = get_shadow_repo_path(path)
    # try to avoid bumblebee
    if not (os.path.exists(os.path.join(spath, ".git")) or \
            os.path.exists(os.path.join(spath, "git"))): 
        raise RuntimeError("No shadow repo found at '%s'" % get_repo_path(path))
    print "delete_shadow_repo: path, spath", path, spath
    subprocess.check_call(["git", "rm", "-rf", spath], cwd=path)

def restore_shadow_repo(cwd="."):
    '''
    Restores the repo from .shadow/git to .shadow/.git.
    Copies the tree into place, then git-rm's the stored version
    to make room for any updates.
    '''
    stored = os.path.join(".shadow", "git")
    live = os.path.join(".shadow", ".git")
    shutil.copytree(stored, live)
    subprocess.check_call(["git", "rm", "-rf", stored], cwd=cwd)

def create_shadow_repo(cwd=".", force=True):
    '''
    Creates a new shadow repo in the conventional subdir below cwd. If shadow 
    repo dir exists and force is False, the script errors out. Otherwise the
    old repo is git-rm'd before the new one is created.
    Called when shadow is initialized and by hooks (such as post-commit).
    '''
    shadow_repo_path = get_shadow_repo_path(cwd)
    if os.path.exists(shadow_repo_path):
        if force == False:
            raise RuntimeError(".shadow already exists in %s" % shadow_repo_path) 
        else:
            delete_shadow_repo(cwd)
 
    # make shadow repo
    print "create_shadow_repo: shadow_repo_path", shadow_repo_path, "cwd", cwd
    subprocess.check_output(["git", "init", shadow_repo_path], cwd=cwd)

def add_hooks(cwd):
    '''
    Create (or add to) git hook files that call git-shadow. 
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["pre-commit", "post-commit", "pre-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        if not os.path.exists(filepath):
            with open(filepath, "wt") as fp:
                fp.write("#!/bin/sh\ngit shadow %s\n" % hook)
            subprocess.check_call(["chmod", "+x", filepath]) # TODO: POSIX only
        else:
            with open(filepath, "at") as fp:
                fp.write("\ngit shadow %s\n" % hook)
    ignore = os.path.join(get_repo_path(cwd), ".gitignore")
    if not os.path.exists(ignore):
        open(ignore, "wt").write("\n.shadow\n")
    else:
        open(ignore, "at").write("\n.shadow\n")

def remove_hooks(cwd):
    '''
    Remove git-shadow hooks from git repo
    '''
    hook_dir = os.path.join(get_repo_path(cwd), ".git", "hooks")
    for hook in ["pre-commit", "post-commit", "pre-checkout"]:
        filepath = os.path.join(hook_dir, hook)
        lines = [l.strip() for l in open(filepath, "rt").readlines()]
        lines = [l for l in lines if "git shadow" not in l]
        # if this hook file was created by git-shadow, delete it
        if len(lines) == 1 and "#!/bin/sh" in lines[0]:
            os.remove(filepath)
        else:
            open(filepath, "wt").write("\n".join(lines))
    ignore = os.path.join(get_repo_path(cwd), ".gitignore")
    if open(ignore, "rt").read() == "\n.shadow\n":
        os.remove(ignore)
    else:
        removed = open(ignore, "rt").read().replace("\n.shadow\n", "")
        open(ignore, "wt").write(removed)


'''
File shadowing functions
'''

def shadow_controlled_files(src_repo_path):
    '''
    Adds all controlled files from repo containing src_repo_path to the
    corresponding shadow repository and commits them
    '''
    src = get_repo_path(src_repo_path)
    dst = get_shadow_repo_path(src_repo_path)
    try:
        rel_fps = subprocess.check_output(["git", "ls-tree", "-r", "HEAD", "--name-only"], cwd=src).strip().splitlines()
    except subprocess.CalledProcessError:
        # this happens when there are no commits in the repo: fatal: Not a valid object name HEAD
        return
    changed = False
    for rel_fp in rel_fps:
        if rel_fp[:len(".shadow")] == ".shadow":
            # don't shadow the shadow 
            print "shadow_controlled_files, skipping", rel_fp
            continue
        dst_filepath = os.path.join(dst, rel_fp)
        dst_dirpath, dst_filename = os.path.split(dst_filepath)
        src_filepath = os.path.join(src, rel_fp)
        try:
            if not os.path.exists(dst_dirpath):
                subprocess.check_call(["mkdir", "-p", dst_dirpath], cwd=src)
            shutil.copy(src_filepath, dst_filepath)
            subprocess.check_call(["git", "add", dst_filepath], cwd=dst)
            changed = True
        except Exception as e:
            import logging
            logging.error("error copying %s to %s, probably uncommitted 'git mv'" % (src_filepath, dst_filepath))
            logging.exception(e)
    if changed:
        subprocess.check_call(["git", "commit", "-m" "'%s'" % get_commit_id(src)], cwd=dst)


def shadow_file(filepath, buffer_path):
    '''
    Diffs contents (respectively) of filepath and buffer_path; if the buffer
    contents are different, the file corresponding to filepath is copied from
    the enclosing repo to the shadow repo and committed to the shadow repo.
    '''
    if not filecmp.cmp(filepath, buffer_path, shallow=False):
        rel = get_filepath_relative_to_repo(filepath)
        shadow_repo = get_shadow_repo_path(filepath)
        dst = os.path.join(shadow_repo, rel)
                
        shutil.copy(buffer_path, dst)
    
        print "committing %s to %s" % (dst, shadow_repo)
        subprocess.check_call(["git", "add", rel], cwd=shadow_repo)
        subprocess.check_call(["git", "commit", "-m", "'file_modified'"], cwd=shadow_repo)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        sys.stderr.write("not enough args")
        sys.exit(-1)

    if len(sys.argv) > 2:
        cwd = sys.argv[2]
    else:
        cwd = "."

    if sys.argv[1] == "activate":
        create_shadow_repo(cwd=cwd, force=False)
        shadow_controlled_files(cwd)
        add_hooks(cwd=cwd)
    elif sys.argv[1] == "deactivate":
        remove_hooks(cwd=cwd)
        delete_shadow_repo(cwd)
    elif sys.argv[1] in ["pre-commit"]:
        print "PRE-COMMIT CALLED FOR", os.path.abspath(cwd)
        remove_hooks(cwd=cwd)
        add_shadow_repo(cwd=cwd)
        add_hooks(cwd=cwd)
    elif sys.argv[1] in ["post-commit"]:
        print "POST-COMMIT CALLED FOR", os.path.abspath(cwd)
        remove_hooks(cwd=cwd)
        create_shadow_repo(cwd=cwd, force=True)
        shadow_controlled_files(cwd)
        add_hooks(cwd=cwd)
    elif sys.argv[1] in ["post-checkout"]: # TODO: this is not a thing, using .gitignore instead
        print "POST-CHECKOUT CALLED FOR", os.path.abspath(cwd)
        remove_hooks(cwd=cwd)
        restore_shadow_repo(cwd=cwd)
        add_hooks(cwd=cwd)
    elif sys.argv[1] == "add-hooks":
        add_hooks(cwd)
    elif sys.argv[1] == "remove-hooks": 
        remove_hooks(cwd)
    elif sys.argv[1] == "shadow-file":
        filepath = sys.argv[2]
        buffer_path = sys.argv[3]
        shadow_file(filepath, buffer_path)
    else:
        # run git command in mirror directory of shadow repo
        pass

"""
TODO:
    1. store shadow to a zip file (or other single file) so that it doesn't clutter up git ls-tree, etc.
    2. figure out why .shadow/git still exists after a commit
    3. fix post-checkout logic
    4. cleanup
"""
